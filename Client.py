#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Patrick Lewis for COMP 431 Spring 2026
HW4: Building an SMTP Client/Server System Using Sockets
Client.py
"""

import argparse
import sys
from Parser import Parser, ParserError, DebugMode, socket_is_connected, socket_send_msg, get_hostname, close_socket
import socket

class SMTPClientSide:
    """
    Class that will operate like a state machine to keep track of what command
    is being handled next.
    """

    # All of these steps are just receiving user data
    EXPECTING_USER_MAIL_FROM_ADDRESS = 0
    EXPECTING_USER_TO_ADDRESSES = 1
    EXPECTING_USER_SUBJECT = 2
    EXPECTING_USER_MESSAGE = 3

    # After the user has entered a valid email message, your mail agent will create a TCP socket to
    # the SMTP server and forward the user's message to the server using the SMTP protocol.
    EXPECTING_SERVER_GREETING = 4 # Received 220
    EXPECTING_SERVER_HELLO = 5 # Received 250 Hello client...

    EXPECTING_MAIL_FROM = 6
    """
    Represents the "MAIL FROM:" command. Only occurs once.
    """
    EXPECTING_RCPT_TO = 7
    """
    Represents the "RCPT TO:" command, specifically this one time because at
    lease one "RCPT TO:" command is required for a well-formed email message.
    """
    EXPECTING_RCPT_TO_OR_DATA = 8
    """
    Represents 0 or more "RCPT TO:" commands or the first line of the email body
    inside a forward file.
    """
    EXPECTING_DATA_END = 9

    EXPECTING_QUIT_RESPONSE = 10
    """
    Before terminating the program, you must wait for a response from the server after you send
    the SMTP QUIT command.
    """

    def __init__(self, debug_mode: bool = False):
        self.state = self.EXPECTING_USER_MAIL_FROM_ADDRESS
        self.parser = None
        self.debug_mode = debug_mode
        self.generated_cmd = ""
        self.cmd_to_send_to_server = ""

        self.forward_file_lines = []

        self.data_to_address_line = ""
        self.data_subject_line = ""

        self.input_line = ""
        """
        This is the current line from the user. This will be useful
        in instances where the existence of a line signals the change in state
        but must be printed to standard out (stdout).
        """

    def set_parser(self, current_parser: Parser):
        """
        By the time the parser is set, the line has already been read. That means,
        what we do is check the current state and act accordingly.
        """
        if not isinstance(current_parser, Parser):
            raise ValueError("parser must be an instance of Parser class.")

        self.parser = current_parser

    def set_socket(self, connection_socket: socket):
        """
        Docstring for set_socket

        :param self: Description
        :param connection_socket: Description
        :type connection_socket: socket
        :return: Description
        :rtype: Any
        """
        if not socket_is_connected(connection_socket, self.debug_mode):
            raise ValueError("client connection_socket must be an instance of the socket class.")

        self.connection_socket = connection_socket

    def get_generated_cmd(self) -> str:
        """
        This is the command, if any, that is generated when a line from the forward file is analyzed
        based on the current state.
        """

        return self.generated_cmd

    def get_state(self):
        """
        Get the current state of the SMTPClientSide.
        """

        return self.state


    def evaluate_state(self, end_of_file: bool = False) -> bool:
        """
        Based on the current state, print to standard output the appropriate SMTP message.
        Since we can assume that forward files are well-formed, we do not even have to validate and
        just get what we need.

        If an SMTP response message should be in sent by the user after this command, then
        return True.
        """
        if not isinstance(self.parser, Parser):
            raise ValueError("parser must be an instance of Parser class.")

        DebugMode.print(self.debug_mode, "evaluate_state(client): parser is valid.")

        if not socket_is_connected(self.connection_socket, self.debug_mode):
            raise ValueError("client connection_socket must be an instance of the socket class.")

        DebugMode.print(self.debug_mode, "evaluate_state(client): socket is valid.", DebugMode.INFO)

        # generated_cmd is what is generated by the parser
        self.generated_cmd = ""

        DebugMode.print(self.debug_mode, "evaluate_state(client): after self.generated_cmd", DebugMode.INFO)

        self.input_line = self.parser.get_input_line()

        DebugMode.print(self.debug_mode, "evaluate_state(client): after self.parser.get_input_line()", DebugMode.INFO)

        self.cmd_to_send_to_server = ""

        DebugMode.print(self.debug_mode, f"evaluate_state(client): state: {self.state}", DebugMode.INFO)

        if self.state == self.EXPECTING_USER_MAIL_FROM_ADDRESS:
            prompt = "From:"
            print(prompt)
            line = sys.stdin.readline()
            temp_parser = Parser(input_string=line, debug_mode=self.debug_mode)
            while not (temp_parser.mailboxes() and len(temp_parser.get_email_addresses()) == 1):
                print(prompt)
                line = sys.stdin.readline()
                temp_parser = Parser(input_string=line, debug_mode=self.debug_mode)

            # Add the one from address to the list of "forward file lines"
            self.forward_file_lines.append(f"{prompt} <{temp_parser.get_input_line()}>")

            self.advance()
            return False

        if self.state == self.EXPECTING_USER_TO_ADDRESSES:
            prompt = "To:"
            print(prompt)
            line = sys.stdin.readline()
            temp_parser = Parser(input_string=line, debug_mode=self.debug_mode)
            while not (temp_parser.mailboxes() and len(temp_parser.get_email_addresses()) >= 1):
                print(prompt)
                line = sys.stdin.readline()
                temp_parser = Parser(input_string=line, debug_mode=self.debug_mode)

            # Add all of the to addresses to the list of forward file lines
            for email in temp_parser.get_email_addresses():
                self.forward_file_lines.append(f"{prompt} <{email}>")

            # This will be helpful later when building the DATA message
            self.data_to_address_line = ", ".join(f"<{e.strip()}" for e in temp_parser.get_email_addresses())

        if self.state == self.EXPECTING_USER_SUBJECT:
            prompt = "Subject:"
            print(prompt)
            line = sys.stdin.readline()
            temp_parser = Parser(input_string=line, debug_mode=self.debug_mode)
            while not (temp_parser.match_arbitrary_text()):
                print(prompt)
                line = sys.stdin.readline()
                temp_parser = Parser(input_string=line, debug_mode=self.debug_mode)

            # Add the one from address to the list of "forward file lines"
            self.data_subject_line = f"{prompt} <{temp_parser.get_input_line()}>"
            self.forward_file_lines.append(self.data_subject_line)

        if self.state == self.EXPECTING_USER_MESSAGE:
            # Now that we have made it here, it is safe to add the required text as lines in the
            # message
            self.forward_file_lines.append(self.forward_file_lines[0])
            self.forward_file_lines.append(self.data_to_address_line)
            self.forward_file_lines.append(self.data_subject_line)
            self.forward_file_lines.append("")

            prompt = "Message:"
            print(prompt)
            line = sys.stdin.readline()
            temp_parser = Parser(input_string=line, debug_mode=self.debug_mode)
            while not (temp_parser.data_end_cmd()):
                self.forward_file_lines.append(line)
                line = sys.stdin.readline()
                temp_parser = Parser(input_string=line, debug_mode=self.debug_mode)

            self.forward_file_lines.append(line)

        if self.state == self.EXPECTING_SERVER_GREETING:
            if not (self.parser.match_response_code and self.parser.get_smtp_response_code() == '220'):
                print('Invalid greeting message from SMTP Server. Terminating program.')
                close_socket(self.connection_socket, self.debug_mode)
                sys.exit(1)

            socket_send_msg(self.connection_socket, f"HELO {get_hostname(self.connection_socket)}", self.debug_mode)
            return True

        if self.state == self.EXPECTING_SERVER_HELLO:
            if not self.parser.match_helo_msg():
                print("Invalid Hello message from SMTP server. Terminating program.")
                close_socket(self.connection_socket, self.debug_mode)
                sys.exit(1)

            return False

        if self.state == self.EXPECTING_MAIL_FROM:
            print(self.parser.generate_mail_from_cmd())
            return True

        if self.state == self.EXPECTING_RCPT_TO:
            print(self.parser.generate_rcpt_to_cmd())
            return True

        if self.state == self.EXPECTING_RCPT_TO_OR_DATA:
            if self.parser.forwardfile_match_to_address():
                self.generated_cmd = "RCPT TO"
                print(self.parser.generate_rcpt_to_cmd())
                return True

            # If we made it here, that means that the text is NOT "To: <emailaddress>"
            # This text, then, is the first line of the body of the email.
            # We need to:
            # 1. Send the "DATA" command
            # 2. Prompt the user for an SMTP response
            self.generated_cmd = "DATA"
            print(self.parser.generate_data_cmd())
            return True

        if self.state == self.EXPECTING_DATA_END:
            if self.parser.forwardfile_match_from_address():
                self.generated_cmd = "MAIL FROM"
                print(self.parser.generate_data_end_cmd())
                return True

            if end_of_file:
                print(self.parser.generate_data_end_cmd())
                return True

            # If we are here, that means the we are reading lines in the forward
            # file that are part of the body of the email message.
            print(self.parser.get_input_line())

        return False

    def print_to_stderr(self, text: str):
        """
        Prints the specified text to standard error (without using the print() function).
        """

        # Apparently, print() was printing an extra line
        DebugMode.print(self.debug_mode, text, DebugMode.ERROR)

    def debug_print(self, text: str):
        if not self.debug_mode:
            return

        print(text)

    def evaluate_response(self, end_of_file: bool = False) -> bool:
        """
        Based on the current state:
        1) Read the "server" response message, which could be either 250, 354, 500, 501, etc. If
        a success message is given (based on the context), then it is okay to advance to the
        next state (as appropriate). This comes from the user (standard input).
        2) Make sure to only validate the response message number only, as the text after the
        number can be anything.
        3) When echoing the response, print to standard error (stderr)!

        The return value here determines whether we need to process the input file again after
        advancing the state. This happens in 3 scenarios:

        1) Encountering the first line of the email body, switching to EXPECTING_DATA_END state
        2) Encountering the "From:" line of a new email, switching from EXPECTING_DATA_END to EXPECTING_MAIL_FROM
        3) Encountering the end-of-file (empty string), switching from EXPECTING_DATA_END to EXPECTING_MAIL_FROM
        """
        if not isinstance(self.parser, Parser):
            raise ValueError("parser must be an instance of Parser class.")

        # No matter what message is received, echo it to stderr
        self.print_to_stderr(self.parser.get_input_line_raw())

        # Stop here if the response is not properly formatted according to the provided
        # production rule; technically, some kind of error occurred
        if not self.parser.match_response_code():
            self.debug_print(f"evaluate_response(); the parsed message was not a response code: {self.parser.get_input_line()}")
            self.quit_immediately()
            return False

        # Stop here if a properly formatted error message is received
        if self.parser.is_error_smtp_response_code():
            self.debug_print(f"evaluate_response(); the parsed message is an error code: {self.parser.get_input_line()}")
            self.quit_immediately()
            return False

        # Based on the state, if the wrong message is received, then quit immediately
        resp_number = self.parser.get_smtp_response_code()

        self.debug_print(f"evaluate_response(); state: {self.state}, resp_number: {resp_number}, generated_cmd: {self.generated_cmd}")

        if self.state in [self.EXPECTING_MAIL_FROM, self.EXPECTING_RCPT_TO, self.EXPECTING_DATA_END] \
        and resp_number != '250':
            self.debug_print(f"wrong response code for state '{self.state}': {resp_number}")
            self.quit_immediately()
            return False

        if self.state == self.EXPECTING_RCPT_TO_OR_DATA:
            if (self.generated_cmd == "DATA" and resp_number != '354') or \
            (self.generated_cmd != "DATA" and resp_number != '250'):
                self.debug_print(f"wrong response code for state '{self.state}': {resp_number}")
                self.quit_immediately()
                return False

        # Handle the three reasons to re-evaluate the current line from the forward file after
        # advancing the state
        # 1) Encountering the first line of the email body, switching to EXPECTING_DATA_END state
        if self.state == self.EXPECTING_RCPT_TO_OR_DATA and self.generated_cmd == "DATA":
            self.advance()
            return True

        # 2) Encountering the "From:" line of a new email, switching from EXPECTING_DATA_END to EXPECTING_MAIL_FROM
        if self.state == self.EXPECTING_DATA_END and self.generated_cmd == "MAIL FROM":
            self.advance()
            return True

        # 3) Encountering the end-of-file (empty string), switching from EXPECTING_DATA_END to EXPECTING_MAIL_FROM
        if self.state == self.EXPECTING_DATA_END and end_of_file:
            self.debug_print("evaluate_response(); end-of-file reached, QUIT should be printed next")
            return self.quit_immediately()

        # 4) # If the generated command is "RCPT TO:", then do NOT advance and there is NO need
        # to process the input string (most likely an email address) again.
        # Only advance if the "DATA" command has been determined to be needed by evaluate_state()
        if self.state == self.EXPECTING_RCPT_TO_OR_DATA and self.generated_cmd != "DATA":
            return False

        # Since you only reach this point if a valid response code is entered, then it is safe
        # to advance the state.
        self.advance()

        self.debug_print(f"evaluate_response(); no re-evaluation of the line necessary.")
        return False

    def reset(self):
        """
        Resets the SMTP server state machine to expect a new email.

        NOTE: Do not clear the generated_cmd as we need to know when the email loops..
        """
        self.state = self.EXPECTING_USER_MAIL_FROM_ADDRESS
        # self.generated_cmd = ""
        self.parser = None
        self.cmd_to_send_to_server = ""
        self.input_line = ""
        self.forward_file_lines = []

        self.data_to_address_line = ""
        self.data_subject_line = ""

    def advance(self):
        """
        Advances the state of the SMTP server by 1. If a message is completed,
        then it starts over and waits for the next one.
        """

        next_state = self.EXPECTING_SERVER_GREETING if self.state == self.EXPECTING_DATA_END else self.state + 1

        self.debug_print(f"advancing state from {self.state} to {next_state}")

        self.state = next_state
        if (next_state == self.EXPECTING_SERVER_GREETING):
            self.reset()

    def quit_immediately(self):
        """
        Upon receiving any error message from the SMTP "server" or otherwise encountering an error,
        you should stop processing email, emit the SMTP message "QUIT" to standard output, and
        terminate your program.

        When you reach the end of the forward file, send the SMTP message "QUIT".

        If you received an SMTP error response, write the response message received (the whole thing)
        to stderr before quitting. This still aligns with echoing the received SMTP response message
        to stderr, just with the extra step of quitting.
        """

        print("QUIT")
        sys.exit(0)



def get_command_line_arguments():
    """
    Your mail agent should take two command line arguments:
    a hostname followed by a port number
    Enables debug mode.
    """

    arg_parser = argparse.ArgumentParser(description="HW4: Building an SMTP Client/Server System Using Sockets")
    # https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument
    arg_parser.add_argument(
        "--debug",
        # https://docs.python.org/3/library/argparse.html#action
        action="store_true",
        help="Enable additional logging that is helpful for debugging without modifying code."
    )

    arg_parser.add_argument(
        "hostname",
        # https://docs.python.org/3/library/argparse.html#action
        # 'store' - This just stores the argument's value. This is the default action.
        action="store",
        help="hostname of the SMTP server to connect to",
        # https://docs.python.org/3/library/argparse.html#type
        # TODO: Make sure setting this does not create issues; the default is to store this value
        # as a "simple string"
        # type=default
    )

    arg_parser.add_argument(
        "port_number",
        # https://docs.python.org/3/library/argparse.html#action
        # 'store' - This just stores the argument's value. This is the default action.
        action="store",
        help="Port number of the SMTP server to connect to",
        # https://docs.python.org/3/library/argparse.html#type
        # TODO: Make sure setting this does not create issues; the default is to store this value
        # as a "simple string"
        type=int
    )

    return arg_parser.parse_args()

def main():
    """
    Docstring for main
    """

    # Get debug_mode, hostname, and port_number
    args = get_command_line_arguments()
    debug_mode = args.debug
    server_name = args.hostname
    # 8000 + 4956 = 12956
    server_port = args.port_number

    # This is the maximum amount of data, in bytes, that can be received or sent via the socket.
    bufsize = 1024

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_socket:

        DebugMode.print(debug_mode, "entered the with statement for client_socket...")

        # Even when the client quits, it must send a message to the server before terminating,
        # so this is a safe place to create the client
        smtp_client = SMTPClientSide(debug_mode)

        try:

            # Print a "From:" prompt message (terminated with a newline)
            print("From:")
            email_from_address = sys.stdin.readline()

            # Users should be able to specify multiple email recipients by providing a list of
            # comma-separated email addresses (with optional whitespace after the comma)
            # Your program should confirm that data entered in response to both the From and To prompts
            # conforms to the syntax of the <forward-path> and <reverse-path> non-terminals in the SMTP
            # grammar (but without the angle brackets) for the SMTP MAIL FROM and RCPT TO messages.
            # If the data entered is erroneous, your client (this program) should print out a 1-line English
            # (not an SMTP) error message identifying the error (similar to what you did in HW1) and
            # re-prompt the user for the correct input.
            #
            # Make sure there is at least 1 valid email address
            # Make sure all email addresses are valid
            # there should be optional whitespace after the comma (using the same
            # definition as <nullspace>, meaning 0 or more spaces)
            # The non-terminal <mailbox> matches the email addresses.

            print("To:")
            email_to_addresses = sys.stdin.readline()

            print("Subject:")
            email_subject = sys.stdin.readline()

            # Assume users will terminate their message text by entering a period on an otherwise blank

            # line (data_end_cmd)
            print("Message:")
            email_body = ""
            email_line = ""
            while email_line != ".\n":
                email_line = sys.stdin.readline()
                email_body += email_line

            # After the user has entered a valid email message, this program will create a TCP socket to the
            # SMTP server at the host and port number specified on the command line.
            # Once the TCP socket has been created, forward the user's message to the server using the
            # SMTP protocol.

            # 1. When your program connects to the server, it must be prepared to
            # receive a correct greeting message. Your program will do nothing with the
            # greeting message other than receive it and confirm that it is a valid
            # greeting message (220 hostname.cs.unc.edu)
            # 1a. If the greeting message is not a valid greeting message, you should
            # print a 1-line error message to stdout and then terminate the program.
            # 1b. If the greeting message is valid, you should reply to the greeting
            # with the SMTP HELO message using the format from the non-terminal. It
            # will look like "HELO client-hostname.cs.unc.edu", where that is a
            # hostname of the server the client program is running on.

            client_socket.connect((server_name, server_port))

            DebugMode.print(debug_mode, f"opened a socket to SMTP server {server_name}:{server_port}", DebugMode.INFO)

            # Attempt to receive the greeting message
            data = client_socket.recv(bufsize).decode()

            DebugMode.print(debug_mode, f"data received: {data}")

            parser = Parser(input_string=data, debug_mode=debug_mode)
            smtp_client.set_parser(current_parser=parser)
            smtp_client.set_socket(client_socket)

            DebugMode.print(debug_mode, "successfully set the client_socket in the smtp_client variable.")

            smtp_client.evaluate_state()

            DebugMode.print(debug_mode, "evaluate_state(client) is completed.")

            # Four new operations:

            # 1. When your program connects to the server, it must be prepared to
            # receive a correct greeting message. Your program will do nothing with the
            # greeting message other than receive it and confirm that it is a valid
            # greeting message (220 hostname.cs.unc.edu)
            # 1a. If the greeting message is not a valid greeting message, you should
            # print a 1-line error message to stdout and then terminate the program.
            # 1b. If the greeting message is valid, you should reply to the greeting
            # with the SMTP HELO message using the format from the non-terminal. It
            # will look like "HELO client-hostname.cs.unc.edu", where that is a
            # hostname of the server the client program is running on.

            # 2. It looks like you send the SMTP commands in order like before, MAIL
            # FROM, RCPT TO, DATA. This time, within the DATA message, you include
            # "From:", "To:", "Subject:", each on their own lines. After the "Subject:"
            # line, have a blank line before the start of the body of the email message.
            # When you send the message, the email addresses in "From:" and
            # "To:" should be wrapped in angle brackets (<>)
            # The message would include the data_end_cmd, which is a line with just
            # a period. The next line would be just "QUIT" for the quit command.
            # 2a. Note that the forward files are now named by domain and not email address
            # on the server.
            # 2b. What is added to the forward files on the server comes from the body
            # of the DATA message, not from the MAIL FROM and RCPT TO messages. For now,
            # don't worry about making them match unless the homework says to make sure
            # that they do.

            # 3. Your program will close its connection to the server, print to stdout
            # a meaningful 1-line error message, and terminate when:
            # end-of-file is reached
            # outgoing mail message has been successfully sent
            # when any SMTP or socket error is encountered
            # any SMTP protocol errors
            # errors opening the socket
            # keyboard quitting, like before

            # 4. When your client emits the QUIT message (which I imagine only happens
            # when sending SMTP messages to the server), the client has to wait and
            # expect the server's final 221 "connection closed" response. Do NOT
            # terminate until after receiving this message.
            # 4a. If the wrong message is given, I suppose you print a 1-line error
            # to standard out and terminate the client application.

        except EOFError:
            # Ctrl+D (Unix) or end-of-file from a pipe
            # break
            pass
        except KeyboardInterrupt:
            # Ctrl+C
            # break
            pass
        except ParserError as pe:
            # All errors that should be handled according to the writeup are handled as ParserError
            # objects. All other exceptions are ValueError or some other type. If a ParserError
            # occurrs, the write up says "upon receipt of any erroneous SMTP message you should
            # reset your state machine and return to the state of waiting for a valid MAIL FROM
            # message".
            # TODO: This must change!
            print(pe)
            # server.reset()
            # continue
        except Exception as e:
            # print(f"An unexpected error occurred: {e}")
            # break
            pass

\



if __name__ == "__main__":
    main()
